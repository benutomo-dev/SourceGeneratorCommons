using Microsoft.CodeAnalysis;
using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Text;

namespace SourceGeneratorCommons;

internal class SourceBuilder : IDisposable
{
    public const string AutoGeneratedComment = "// <auto-generated/>";

    public const string DesignerFileSuffix = ".designer.cs";
    public const string LongGeneratedFileSuffix = ".generated.cs";
    public const string ShortGeneratedFileSuffix = ".g.cs";
    public const string GiFileSuffix = ".g.i.cs";
    public const string TemporaryGeneratedFilePrefix = "TemporaryGeneratedFile_";

    public string SourceText => _cachedSourceText ??= _buffer?.AsSpan(0, _length).ToString() ?? "";

    private string? _cachedSourceText;

    private int _length;

    private char[]? _buffer;

    private int _currentIndentCount;

    private CancellationToken _cancellationToken;

    private Action<string, string> _addSource;

    private string _hintName;

    private const string IndentText = "    ";

    private static ConcurrentDictionary<string, int> _initialBufferSizeDictionary = new ConcurrentDictionary<string, int>();

    public SourceBuilder(SourceProductionContext context, string hintName)
        :this(hintName, context.AddSource, context.CancellationToken)
    {
    }

    public SourceBuilder(IncrementalGeneratorPostInitializationContext context, string hintName)
        : this(hintName, context.AddSource, context.CancellationToken)
    {
    }

    public SourceBuilder(string hintName, Action<string, string> addSource, CancellationToken cancellationToken)
    {
        _cancellationToken = cancellationToken;
        _addSource = addSource;
        _hintName = hintName;

        if (!_initialBufferSizeDictionary.TryGetValue(hintName, out var initialMinimumCapacityLength))
        {
            initialMinimumCapacityLength = 1024;
        }
        _buffer = ArrayPool<char>.Shared.Rent(initialMinimumCapacityLength);
        _length = 0;
    }

    public void Dispose()
    {
        if (_buffer is not null)
        {
            _length = 0;
            ArrayPool<char>.Shared.Return(_buffer);
            _buffer = null;
        }
    }

    public void Commit()
    {
        _addSource(_hintName, SourceText);

        _initialBufferSizeDictionary.AddOrUpdate(_hintName, _length, (_, _) => _length);

        Dispose();
    }

    void ExpandBuffer(int requiredSize)
    {
        if (_buffer is null) throw new ObjectDisposedException(null);

        _cancellationToken.ThrowIfCancellationRequested();

        Debug.Assert(_buffer.Length < _length + requiredSize);

        var nextBuffer = ArrayPool<char>.Shared.Rent((_buffer.Length + requiredSize) * 2);

        _buffer.CopyTo(nextBuffer.AsSpan());

        ArrayPool<char>.Shared.Return(_buffer);

        _buffer = nextBuffer;
    }

    void InternalClear()
    {
        if (_length != 0)
        {
            _cachedSourceText = null;
            _length = 0;
        }
    }

    void InternalAppend(ReadOnlySpan<char> text)
    {
        if (_buffer is null) throw new ObjectDisposedException(null);

        _cancellationToken.ThrowIfCancellationRequested();

        if (text.Length <= 0) return;

        _cachedSourceText = null;

        if (_buffer.Length < _length + text.Length)
        {
            ExpandBuffer(text.Length);
        }

        text.CopyTo(_buffer.AsSpan(_length));
        _length += text.Length;
    }

    public void PutIndentSpace()
    {
        for (int i = 0; i < _currentIndentCount; i++)
        {
            InternalAppend(IndentText.AsSpan());
        }
    }

    public void Clear()
    {
        InternalClear();
    }

    public void Append(string text) => Append(text.AsSpan());

    public void AppendLine(string text) => AppendLine(text.AsSpan());

    public void AppendLineWithFirstIndent(string text)
    {
        PutIndentSpace();
        AppendLine(text.AsSpan());
    }

    public _BlockEndDisposable BeginBlock(string text) => BeginBlock(text.AsSpan());

    public void Append(ReadOnlySpan<char> text)
    {
        InternalAppend(text);
    }


    public void AppendLine(ReadOnlySpan<char> text)
    {
        InternalAppend(text);
        AppendLine();
    }

    public void AppendLine()
    {
        InternalAppend("\r\n".AsSpan());
    }

    public _BlockEndDisposable BeginTypeDefinitionBlock(TypeDefinitionInfo typeDefinitionInfo, string? classDeclarationLineTail = null)
    {
        return beginTypeBlock(this, typeDefinitionInfo, isDestinationType: true, classDeclarationLineTail);

        static _BlockEndDisposable beginTypeBlock(SourceBuilder self, TypeDefinitionInfo typeDefinitionInfo, bool isDestinationType, string? classDeclarationLineTail)
        {
            _BlockEndDisposable outerBlockEnd = default;

            if (typeDefinitionInfo.Container is NameSpaceInfo nameSpace && !string.IsNullOrWhiteSpace(nameSpace.Name))
            {
                outerBlockEnd = beginNameSpace(self, nameSpace);
            }
            else if (typeDefinitionInfo.Container is TypeDefinitionInfo typeInfo)
            {
                outerBlockEnd = beginTypeBlock(self, typeInfo, isDestinationType: false, null);
            }

            self.PutIndentSpace();
            self.Append(typeDefinitionInfo.Accessibility switch
            {
                CSharpAccessibility.Public            => "public ",
                CSharpAccessibility.Internal          => "internal ",
                CSharpAccessibility.Protected         => "protected ",
                CSharpAccessibility.ProtectedInternal => "protected internal ",
                CSharpAccessibility.Private           => "private ",
                _ => "",
            });
            if (typeDefinitionInfo.IsStatic)
                self.Append("static ");
            self.Append(typeDefinitionInfo.ClassModifier switch
            {
                ClassModifier.Sealed   => "sealed ",
                ClassModifier.Abstract => "abstract ",
                _ => "",
            });
            if (typeDefinitionInfo.IsReadOnly)
                self.Append("readonly ");
            if (typeDefinitionInfo.IsRef)
                self.Append("ref ");
            self.Append("partial ");
            self.Append(typeDefinitionInfo.TypeCategory switch
            {
                TypeCategory.Enum   => "enum ",
                TypeCategory.Struct => "struct ",
                _ => "class ",
            });
            self.Append(typeDefinitionInfo.Name);

            if (!typeDefinitionInfo.GenericTypeParams.IsDefaultOrEmpty)
            {
                self.Append("<");

                for (int i = 0; i < typeDefinitionInfo.GenericTypeParams.Length; i++)
                {
                    var genericTypeArg = typeDefinitionInfo.GenericTypeParams[i];

                    self.Append(genericTypeArg.Name);

                    if (i < typeDefinitionInfo.GenericTypeParams.Length - 1)
                    {
                        self.Append(", ");
                    }
                }

                self.Append(">");

                var hintingTypeNameBuilder = new StringBuilder();

                hintingTypeNameBuilder.Append(typeDefinitionInfo.Name);
                hintingTypeNameBuilder.Append('{');
                hintingTypeNameBuilder.Append(string.Join("_", typeDefinitionInfo.GenericTypeParams));
                hintingTypeNameBuilder.Append('}');
            }

            if (isDestinationType)
            {
                var inheritTypeCount = 0;
                if (typeDefinitionInfo.BaseType is not null)
                    inheritTypeCount += 1;

                if (!typeDefinitionInfo.Interfaces.IsDefaultOrEmpty)
                    inheritTypeCount += typeDefinitionInfo.Interfaces.Length;

                if (inheritTypeCount > 0)
                {
                    self.Append(" : ");

                    var inheritTypes = new List<TypeReferenceInfo>(inheritTypeCount);

                    if (typeDefinitionInfo.BaseType is not null)
                        inheritTypes.Add(typeDefinitionInfo.BaseType);

                    if (!typeDefinitionInfo.Interfaces.IsDefaultOrEmpty)
                        inheritTypes.AddRange(typeDefinitionInfo.Interfaces.Values);

                    for (int i = 0; i < inheritTypes.Count; i++)
                    {
                        self.Append(inheritTypes[i].ToString());

                        if (i != inheritTypes.Count - 1)
                            self.Append(", ");
                    }
                }

                if (classDeclarationLineTail is not null)
                {
                    self.Append(classDeclarationLineTail);
                }
            }

            self.AppendLine("");

            return self.BeginBlock().Combine(outerBlockEnd);
        }

        static _BlockEndDisposable beginNameSpace(SourceBuilder self, NameSpaceInfo namespaceSymbol)
        {
            self.PutIndentSpace();
            self.Append("namespace ");
            self.Append(namespaceSymbol.Name);
            self.AppendLine("");

            return self.BeginBlock();
        }
    }

    public _BlockEndDisposable BeginMethodDefinitionBlock(MethodDefinitionInfo methodDefinitionInfo, string? methodDeclarationLineTail = null)
    {
        PutIndentSpace();
        Append(methodDefinitionInfo.Accessibility switch
        {
            CSharpAccessibility.Public => "public ",
            CSharpAccessibility.Internal => "internal ",
            CSharpAccessibility.Protected => "protected ",
            CSharpAccessibility.ProtectedInternal => "protected internal ",
            CSharpAccessibility.Private => "private ",
            _ => "",
        });
        if (methodDefinitionInfo.IsStatic)
            Append("static ");
        if (methodDefinitionInfo.IsAsync)
            Append("async ");
        if (methodDefinitionInfo.IsReadOnly)
            Append("readonly ");

        Append(methodDefinitionInfo.MethodModifier switch
        {
            MethodModifier.SealedOverride => "sealed override ",
            MethodModifier.Override       => "override ",
            MethodModifier.Virtual        => "virtual ",
            MethodModifier.Abstract       => "abstract ",
            _ => "",
        });
        Append("partial ");
        Append(methodDefinitionInfo.ReturnModifier switch
        {
            ReturnModifier.RefReadonly=> "ref readonly ",
            ReturnModifier.Ref => "ref ",
            _ => "",
        });
        Append(methodDefinitionInfo.ReturnType.ToString());
        Append(" ");
        Append(methodDefinitionInfo.Name);
        if (!methodDefinitionInfo.GenericTypeParams.IsDefaultOrEmpty)
        {
            Append("<");

            for (int i = 0; i < methodDefinitionInfo.GenericTypeParams.Length; i++)
            {
                var genericTypeArg = methodDefinitionInfo.GenericTypeParams[i];

                Append(genericTypeArg.Name);

                if (i < methodDefinitionInfo.GenericTypeParams.Length - 1)
                {
                    Append(", ");
                }
            }

            Append(">");

            var hintingTypeNameBuilder = new StringBuilder();

            hintingTypeNameBuilder.Append(methodDefinitionInfo.Name);
            hintingTypeNameBuilder.Append('{');
            hintingTypeNameBuilder.Append(string.Join("_", methodDefinitionInfo.GenericTypeParams));
            hintingTypeNameBuilder.Append('}');
        }
        Append("(");
        if (!methodDefinitionInfo.Params.IsDefaultOrEmpty)
        {
            for (int i = 0; i < methodDefinitionInfo.Params.Length; i++)
            {
                var param = methodDefinitionInfo.Params[i];

                if (param.IsScoped)
                    Append("scoped ");

                Append(param.Modifier switch
                {
                    ParamModifier.RefReadOnly => "ref readonly ",
                    ParamModifier.In => "in ",
                    ParamModifier.Ref => "ref ",
                    ParamModifier.Out => "out ",
                    _ => "",
                });

                Append(param.Name);

                if (i < methodDefinitionInfo.Params.Length - 1)
                {
                    Append(", ");
                }
            }
        }
        Append(")");
        if (methodDeclarationLineTail is not null)
        {
            Append(methodDeclarationLineTail);
        }
        AppendLine("");

        if (!methodDefinitionInfo.GenericTypeParams.IsDefaultOrEmpty)
        {
            var genericTypeParams = methodDefinitionInfo.GenericTypeParams.Values.Where(v => v.Where.HasValue).ToArray();
            if (genericTypeParams.Length > 0)
            {
                using (BeginIndent())
                {
                    foreach (var genericTypeParam in genericTypeParams)
                    {
                        PutIndentSpace();
                        Append("where ");
                        Append(genericTypeParam.Name);
                        Append(" : ");

                        var constraints = genericTypeParam.Where!.Value;

                        bool existsLeadingConstraint = false;

                        appendConstraint(this, ref existsLeadingConstraint, constraints.TypeCategory switch
                        {
                            GenericConstraintTypeCategory.Struct => "struct",
                            GenericConstraintTypeCategory.Class => "class",
                            GenericConstraintTypeCategory.NullableClass => "class?",
                            GenericConstraintTypeCategory.NotNull => "notnull",
                            GenericConstraintTypeCategory.Unmanaged => "unmanaged",
                            _ => null,
                        });

                        appendConstraint(this, ref existsLeadingConstraint, constraints.HaveDefaultConstructor switch
                        {
                            true => "new()",
                            _ => null,
                        });

                        appendConstraint(this, ref existsLeadingConstraint, constraints.BaseType?.ToString());

                        foreach (var interfaceConstraint in constraints.Interfaces.Values)
                        {
                            appendConstraint(this, ref existsLeadingConstraint, interfaceConstraint.ToString());
                        }

                        AppendLine("");
                    }
                }
            }
        }
    
        return BeginBlock();


        static void appendConstraint(SourceBuilder self, ref bool existsLeadingConstraint, string? constraint)
        {
            if (constraint is null)
                return;

            if (existsLeadingConstraint)
                self.Append(", ");

            self.Append(constraint);
            existsLeadingConstraint = true;
        }
    }

    public _BlockEndDisposable BeginBlock(ReadOnlySpan<char> blockHeadLine)
    {
        PutIndentSpace();
        InternalAppend(blockHeadLine);
        AppendLine();
        return BeginBlock();
    }

    public _BlockEndDisposable BeginBlock()
    {
        PutIndentSpace();
        InternalAppend("{".AsSpan());
        AppendLine();
        _currentIndentCount++;

        return new _BlockEndDisposable(this);
    }

    private void EndBlock()
    {
        _currentIndentCount--;
        PutIndentSpace();
        InternalAppend("}".AsSpan());
        AppendLine();
    }

    public _IndentDisposable BeginIndent()
    {
        _currentIndentCount++;

        return new _IndentDisposable(this);
    }

    private void EndIndent()
    {
        _currentIndentCount--;
    }


    public ref struct _BlockEndDisposable
    {
        private SourceBuilder? _sourceBuilder;

        private int _nestCount;

        internal _BlockEndDisposable(SourceBuilder? sourceBuilder)
        {    
            _sourceBuilder = sourceBuilder;
            _nestCount = 1;
        }

        public _BlockEndDisposable Combine(_BlockEndDisposable other)
        {
            if (other._sourceBuilder is null && _nestCount == 0) return this;

            if (_nestCount <= 0) throw new InvalidOperationException();
            if (_sourceBuilder != other._sourceBuilder) throw new ArgumentException(null, nameof(other));
            if (other._nestCount <= 0) throw new ArgumentException(null, nameof(other));

            return new _BlockEndDisposable
            {
                _sourceBuilder = _sourceBuilder,
                _nestCount = _nestCount + other._nestCount,
            };
        }

        public void Dispose()
        {
            if (_sourceBuilder is not null)
            {
                for (int i = 0; i < _nestCount; i++)
                {
                    _sourceBuilder.EndBlock();
                }
            }
            _sourceBuilder = null;
            _nestCount = 0;
        }
    }

    public ref struct _IndentDisposable
    {
        private SourceBuilder? _sourceBuilder;

        private int _nestCount;

        internal _IndentDisposable(SourceBuilder? sourceBuilder)
        {
            _sourceBuilder = sourceBuilder;
            _nestCount = 1;
        }

        public void Dispose()
        {
            if (_sourceBuilder is not null)
            {
                for (int i = 0; i < _nestCount; i++)
                {
                    _sourceBuilder.EndIndent();
                }
            }
            _sourceBuilder = null;
            _nestCount = 0;
        }
    }
}
