using Microsoft.CodeAnalysis;
using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Text;

namespace SourceGeneratorCommons;

internal class SourceBuilder : IDisposable
{
    public const string AutoGeneratedComment = "// <auto-generated/>";

    public const string DesignerFileSuffix = ".designer.cs";
    public const string LongGeneratedFileSuffix = ".generated.cs";
    public const string ShortGeneratedFileSuffix = ".g.cs";
    public const string GiFileSuffix = ".g.i.cs";
    public const string TemporaryGeneratedFilePrefix = "TemporaryGeneratedFile_";

    public string SourceText => _cachedSourceText ??= _buffer?.AsSpan(0, _length).ToString() ?? "";

    private string? _cachedSourceText;

    private int _length;

    private char[]? _buffer;

    private int _currentIndentCount;

    private CancellationToken _cancellationToken;

    private Action<string, string> _addSource;

    private string _hintName;

    private const string IndentText = "    ";

    private static ConcurrentDictionary<string, int> _initialBufferSizeDictionary = new ConcurrentDictionary<string, int>();

    public SourceBuilder(SourceProductionContext context, string hintName)
        :this(hintName, context.AddSource, context.CancellationToken)
    {
    }

    public SourceBuilder(IncrementalGeneratorPostInitializationContext context, string hintName)
        : this(hintName, context.AddSource, context.CancellationToken)
    {
    }

    public SourceBuilder(string hintName, Action<string, string> addSource, CancellationToken cancellationToken)
    {
        _cancellationToken = cancellationToken;
        _addSource = addSource;
        _hintName = hintName;

        if (!_initialBufferSizeDictionary.TryGetValue(hintName, out var initialMinimumCapacityLength))
        {
            initialMinimumCapacityLength = 1024;
        }
        _buffer = ArrayPool<char>.Shared.Rent(initialMinimumCapacityLength);
        _length = 0;
    }

    public void Dispose()
    {
        if (_buffer is not null)
        {
            _length = 0;
            ArrayPool<char>.Shared.Return(_buffer);
            _buffer = null;
        }
    }

    public void Commit()
    {
        _addSource(_hintName, SourceText);

        _initialBufferSizeDictionary.AddOrUpdate(_hintName, _length, (_, _) => _length);

        Dispose();
    }

    void ExpandBuffer(int requiredSize)
    {
        if (_buffer is null) throw new ObjectDisposedException(null);

        _cancellationToken.ThrowIfCancellationRequested();

        DebugSGen.Assert(_buffer.Length < _length + requiredSize);

        var nextBuffer = ArrayPool<char>.Shared.Rent((_buffer.Length + requiredSize) * 2);

        _buffer.CopyTo(nextBuffer.AsSpan());

        ArrayPool<char>.Shared.Return(_buffer);

        _buffer = nextBuffer;
    }

    void InternalClear()
    {
        if (_length != 0)
        {
            _cachedSourceText = null;
            _length = 0;
        }
    }

    void InternalAppend(ReadOnlySpan<char> text)
    {
        if (_buffer is null) throw new ObjectDisposedException(null);

        _cancellationToken.ThrowIfCancellationRequested();

        if (text.Length <= 0) return;

        _cachedSourceText = null;

        if (_buffer.Length < _length + text.Length)
        {
            ExpandBuffer(text.Length);
        }

        text.CopyTo(_buffer.AsSpan(_length));
        _length += text.Length;
    }

    public void PutIndentSpace()
    {
        for (int i = 0; i < _currentIndentCount; i++)
        {
            InternalAppend(IndentText.AsSpan());
        }
    }

    public void Clear()
    {
        InternalClear();
    }

    public void Append(string text) => Append(text.AsSpan());

    public void AppendLine(string text) => AppendLine(text.AsSpan());

    public void AppendLineWithFirstIndent(string text)
    {
        PutIndentSpace();
        AppendLine(text.AsSpan());
    }

    public _BlockEndDisposable BeginBlock(string text) => BeginBlock(text.AsSpan());

    public void Append(ReadOnlySpan<char> text)
    {
        InternalAppend(text);
    }


    public void AppendLine(ReadOnlySpan<char> text)
    {
        InternalAppend(text);
        AppendLine();
    }

    public void AppendLine()
    {
        InternalAppend("\r\n".AsSpan());
    }

    public _BlockEndDisposable BeginTypeDefinitionBlock(CsTypeDeclaration typeDeclaration, string? classDeclarationLineTail = null)
    {
        if (typeDeclaration is not CsUserDefinableTypeDeclaration userDefinableTypeDeclaration)
            throw new ArgumentException(null, nameof(typeDeclaration));

        return beginTypeBlock(this, typeDeclaration, isDestinationType: true, classDeclarationLineTail);

        static _BlockEndDisposable beginTypeBlock(SourceBuilder self, CsTypeDeclaration typeDeclaration, bool isDestinationType, string? typeDeclarationLineTail)
        {
            if (typeDeclaration is not CsUserDefinableTypeDeclaration userDefinableTypeDeclaration)
                throw new NotSupportedException();

            bool hasOuterBlock = false;
            _BlockEndDisposable outerBlockEnd = default;

            if (userDefinableTypeDeclaration.Container is NameSpaceInfo nameSpace && !string.IsNullOrWhiteSpace(nameSpace.Name))
            {
                hasOuterBlock = true;
                outerBlockEnd = beginNameSpace(self, nameSpace);
            }
            else if (userDefinableTypeDeclaration.Container is CsTypeDeclaration typeInfo)
            {
                hasOuterBlock = true;
                outerBlockEnd = beginTypeBlock(self, typeInfo, isDestinationType: false, null);
            }

            self.PutIndentSpace();
            self.Append(userDefinableTypeDeclaration.Accessibility switch
            {
                CsAccessibility.Public            => "public ",
                CsAccessibility.Internal          => "internal ",
                CsAccessibility.Protected         => "protected ",
                CsAccessibility.ProtectedInternal => "protected internal ",
                CsAccessibility.Private           => "private ",
                _ => "",
            });

            if (userDefinableTypeDeclaration is CsClassDeclaration classDeclaration)
            {
                self.Append(classDeclaration.ClassModifier switch
                {
                    ClassModifier.Sealed => "sealed ",
                    ClassModifier.Abstract => "abstract ",
                    ClassModifier.Static => "static ",
                    _ => "",
                });

                self.Append("partial ");
                self.Append("class ");
            }
            else if (userDefinableTypeDeclaration is CsInterfaceDeclaration interfaceDeclaration)
            {
                self.Append("partial ");
                self.Append("interface ");
            }
            else if (userDefinableTypeDeclaration is CsStructDeclaration structDeclaration)
            {
                if (structDeclaration.IsReadOnly)
                    self.Append("readonly ");
                if (structDeclaration.IsRef)
                    self.Append("ref ");

                self.Append("partial ");
                self.Append("struct ");
            }
            else if (userDefinableTypeDeclaration is CsEnumDeclaration enumDeclaration)
            {
                self.Append("enum ");
            }
            else
            {
                throw new NotSupportedException();
            }

            self.Append(userDefinableTypeDeclaration.Name);


            if (userDefinableTypeDeclaration is CsGenericDefinableTypeDeclaration { GenericTypeParams: { IsDefaultOrEmpty: false } genericTypeParams })
            {
                self.Append("<");

                for (int i = 0; i < genericTypeParams.Length; i++)
                {
                    var genericTypeArg = genericTypeParams[i];

                    self.Append(genericTypeArg.Name);

                    if (i < genericTypeParams.Length - 1)
                    {
                        self.Append(", ");
                    }
                }

                self.Append(">");
            }

            if (isDestinationType)
            {
                if (userDefinableTypeDeclaration is CsEnumDeclaration enumDeclaration2)
                {
                    self.Append(enumDeclaration2.UnderlyingType switch
                    {
                        EnumUnderlyingType.Byte => " : byte",
                        EnumUnderlyingType.Int16 => " : short",
                        EnumUnderlyingType.Int64 => " : long",
                        EnumUnderlyingType.SByte => " : sbyte",
                        EnumUnderlyingType.UInt16 => " : ushort",
                        EnumUnderlyingType.UInt32 => " : uint",
                        EnumUnderlyingType.UInt64 => " : ulong",
                        _ => "",
                    });
                }
                else
                {
                    var inheritTypeCount = 0;

                    if (userDefinableTypeDeclaration is CsClassDeclaration { BaseType: { } baseType })
                        inheritTypeCount += 1;
                    else
                        baseType = null;

                    if (userDefinableTypeDeclaration is CsClassDeclaration { Interfaces: { IsDefaultOrEmpty: false } classInheritInterfaces })
                        inheritTypeCount += classInheritInterfaces.Length;
                    else
                        classInheritInterfaces = EquatableArray<CsTypeReference>.Empty;

                    if (userDefinableTypeDeclaration is CsStructDeclaration { Interfaces: { IsDefaultOrEmpty: false } structInheritInterfaces })
                        inheritTypeCount += structInheritInterfaces.Length;
                    else
                        structInheritInterfaces = EquatableArray<CsTypeReference>.Empty;

                    if (inheritTypeCount > 0)
                    {
                        self.Append(" : ");

                        var inheritTypes = new List<CsTypeReference>(inheritTypeCount);

                        if (baseType is not null)
                            inheritTypes.Add(baseType);

                        inheritTypes.AddRange(classInheritInterfaces.Values);
                        inheritTypes.AddRange(structInheritInterfaces.Values);

                        for (int i = 0; i < inheritTypes.Count; i++)
                        {
                            self.Append(inheritTypes[i].ToString());

                            if (i != inheritTypes.Count - 1)
                                self.Append(", ");
                        }
                    }
                }

                if (typeDeclarationLineTail is not null)
                {
                    self.Append(typeDeclarationLineTail);
                }
            }

            self.AppendLine("");

            if (hasOuterBlock)
                return self.BeginBlock().Combine(outerBlockEnd);
            else
                return self.BeginBlock();
        }

        static _BlockEndDisposable beginNameSpace(SourceBuilder self, NameSpaceInfo namespaceSymbol)
        {
            self.PutIndentSpace();
            self.Append("namespace ");
            self.Append(namespaceSymbol.Name);
            self.AppendLine("");

            return self.BeginBlock();
        }
    }

    public _BlockEndDisposable BeginMethodDefinitionBlock(CsMethodDeclaration methodDefinitionInfo, string? methodDeclarationLineTail = null)
    {
        PutIndentSpace();
        Append(methodDefinitionInfo.Accessibility switch
        {
            CsAccessibility.Public => "public ",
            CsAccessibility.Internal => "internal ",
            CsAccessibility.Protected => "protected ",
            CsAccessibility.ProtectedInternal => "protected internal ",
            CsAccessibility.Private => "private ",
            _ => "",
        });
        if (methodDefinitionInfo.IsStatic)
            Append("static ");
        if (methodDefinitionInfo.IsAsync)
            Append("async ");
        if (methodDefinitionInfo.IsReadOnly)
            Append("readonly ");

        Append(methodDefinitionInfo.MethodModifier switch
        {
            MethodModifier.SealedOverride => "sealed override ",
            MethodModifier.Override       => "override ",
            MethodModifier.Virtual        => "virtual ",
            MethodModifier.Abstract       => "abstract ",
            _ => "",
        });
        Append("partial ");
        Append(methodDefinitionInfo.ReturnModifier switch
        {
            ReturnModifier.RefReadonly=> "ref readonly ",
            ReturnModifier.Ref => "ref ",
            _ => "",
        });
        Append(methodDefinitionInfo.ReturnType.ToString());
        Append(" ");
        Append(methodDefinitionInfo.Name);
        if (!methodDefinitionInfo.GenericTypeParams.IsDefaultOrEmpty)
        {
            Append("<");

            for (int i = 0; i < methodDefinitionInfo.GenericTypeParams.Length; i++)
            {
                var genericTypeArg = methodDefinitionInfo.GenericTypeParams[i];

                Append(genericTypeArg.Name);

                if (i < methodDefinitionInfo.GenericTypeParams.Length - 1)
                {
                    Append(", ");
                }
            }

            Append(">");

            var hintingTypeNameBuilder = new StringBuilder();

            hintingTypeNameBuilder.Append(methodDefinitionInfo.Name);
            hintingTypeNameBuilder.Append('{');
            hintingTypeNameBuilder.Append(string.Join("_", methodDefinitionInfo.GenericTypeParams));
            hintingTypeNameBuilder.Append('}');
        }
        Append("(");
        if (!methodDefinitionInfo.Params.IsDefaultOrEmpty)
        {
            for (int i = 0; i < methodDefinitionInfo.Params.Length; i++)
            {
                var param = methodDefinitionInfo.Params[i];

                if (param.IsScoped)
                    Append("scoped ");

                Append(param.Modifier switch
                {
                    ParamModifier.RefReadOnly => "ref readonly ",
                    ParamModifier.In => "in ",
                    ParamModifier.Ref => "ref ",
                    ParamModifier.Out => "out ",
                    _ => "",
                });

                Append(param.Name);

                if (i < methodDefinitionInfo.Params.Length - 1)
                {
                    Append(", ");
                }
            }
        }
        Append(")");
        if (methodDeclarationLineTail is not null)
        {
            Append(methodDeclarationLineTail);
        }
        AppendLine("");

        if (!methodDefinitionInfo.GenericTypeParams.IsDefaultOrEmpty)
        {
            var genericTypeParams = methodDefinitionInfo.GenericTypeParams.Values.Where(v => v.Where.HasValue).ToArray();
            if (genericTypeParams.Length > 0)
            {
                using (BeginIndent())
                {
                    foreach (var genericTypeParam in genericTypeParams)
                    {
                        PutIndentSpace();
                        Append("where ");
                        Append(genericTypeParam.Name);
                        Append(" : ");

                        var constraints = genericTypeParam.Where!.Value;

                        bool existsLeadingConstraint = false;

                        appendConstraint(this, ref existsLeadingConstraint, constraints.TypeCategory switch
                        {
                            GenericConstraintTypeCategory.Struct => "struct",
                            GenericConstraintTypeCategory.Class => "class",
                            GenericConstraintTypeCategory.NullableClass => "class?",
                            GenericConstraintTypeCategory.NotNull => "notnull",
                            GenericConstraintTypeCategory.Unmanaged => "unmanaged",
                            _ => null,
                        });

                        appendConstraint(this, ref existsLeadingConstraint, constraints.HaveDefaultConstructor switch
                        {
                            true => "new()",
                            _ => null,
                        });

                        appendConstraint(this, ref existsLeadingConstraint, constraints.BaseType?.ToString());

                        foreach (var interfaceConstraint in constraints.Interfaces.Values)
                        {
                            appendConstraint(this, ref existsLeadingConstraint, interfaceConstraint.ToString());
                        }

                        AppendLine("");
                    }
                }
            }
        }
    
        return BeginBlock();


        static void appendConstraint(SourceBuilder self, ref bool existsLeadingConstraint, string? constraint)
        {
            if (constraint is null)
                return;

            if (existsLeadingConstraint)
                self.Append(", ");

            self.Append(constraint);
            existsLeadingConstraint = true;
        }
    }

    public _BlockEndDisposable BeginBlock(ReadOnlySpan<char> blockHeadLine)
    {
        PutIndentSpace();
        InternalAppend(blockHeadLine);
        AppendLine();
        return BeginBlock();
    }

    public _BlockEndDisposable BeginBlock()
    {
        PutIndentSpace();
        InternalAppend("{".AsSpan());
        AppendLine();
        _currentIndentCount++;

        return new _BlockEndDisposable(this);
    }

    private void EndBlock()
    {
        _currentIndentCount--;
        PutIndentSpace();
        InternalAppend("}".AsSpan());
        AppendLine();
    }

    public _IndentDisposable BeginIndent()
    {
        _currentIndentCount++;

        return new _IndentDisposable(this);
    }

    private void EndIndent()
    {
        _currentIndentCount--;
    }


    public ref struct _BlockEndDisposable
    {
        private SourceBuilder? _sourceBuilder;

        private int _nestCount;

        internal _BlockEndDisposable(SourceBuilder? sourceBuilder)
        {    
            _sourceBuilder = sourceBuilder;
            _nestCount = 1;
        }

        public _BlockEndDisposable Combine(_BlockEndDisposable other)
        {
            if (other._sourceBuilder is null && _nestCount == 0) return this;

            if (_nestCount <= 0) throw new InvalidOperationException();
            if (_sourceBuilder != other._sourceBuilder) throw new ArgumentException(null, nameof(other));
            if (other._nestCount <= 0) throw new ArgumentException(null, nameof(other));

            return new _BlockEndDisposable
            {
                _sourceBuilder = _sourceBuilder,
                _nestCount = _nestCount + other._nestCount,
            };
        }

        public void Dispose()
        {
            if (_sourceBuilder is not null)
            {
                for (int i = 0; i < _nestCount; i++)
                {
                    _sourceBuilder.EndBlock();
                }
            }
            _sourceBuilder = null;
            _nestCount = 0;
        }
    }

    public ref struct _IndentDisposable
    {
        private SourceBuilder? _sourceBuilder;

        private int _nestCount;

        internal _IndentDisposable(SourceBuilder? sourceBuilder)
        {
            _sourceBuilder = sourceBuilder;
            _nestCount = 1;
        }

        public void Dispose()
        {
            if (_sourceBuilder is not null)
            {
                for (int i = 0; i < _nestCount; i++)
                {
                    _sourceBuilder.EndIndent();
                }
            }
            _sourceBuilder = null;
            _nestCount = 0;
        }
    }
}
